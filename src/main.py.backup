"""
Головна програма Mod Manager на PyQt6
"""

import sys
import logging
from pathlib import Path
from PyQt6.QtWidgets import QApplication
from PyQt6.QtCore import QTimer

# Налаштування логування
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('mod_manager.log'),
        logging.StreamHandler()
    ]
)

logger = logging.getLogger(__name__)

# Імпорти модулів програми
from src.core.mod_manager import ModManager
from src.utils.config import ConfigManager
from src.gui.main_window import MainWindow

import logging
import sys
from pathlib import Path

# Налаштування логування
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('mod_manager.log', encoding='utf-8'),
        logging.StreamHandler(sys.stdout)
    ]
)

logger = logging.getLogger(__name__)

from src.core.mod_manager import ModManager
from src.utils.config import ConfigManager
from src.gui.minimal_window import MinimalMainWindow
from src.gui.settings_dialog import SettingsDialog


class ModManagerApp:
    """Головний клас програми"""
    
    def __init__(self):
        """Ініціалізація програми"""
        logger.info("=== Запуск Mod Manager ===")
        
        # Ініціалізація менеджерів
        self.config = ConfigManager()
        self.config.load_config()
        
        # Створюємо ModManager з шляхами з конфігу
        mods_path = self.config.get_mods_path()
        save_path = self.config.get_save_mods_path()
        self.mod_manager = ModManager(mods_path, save_path)
        
        # Створюємо PyQt6 додаток
        self.app = QApplication(sys.argv)
        
        # Створюємо головне вікно
        self.window = MainWindow()
        
        # Підключаємо callbacks
        self.window.on_mod_toggle = self.on_toggle_mod
        self.window.on_refresh = self.on_refresh
        self.window.on_settings_save = self.on_settings_save
        
        # Встановлюємо поточні шляхи в налаштуваннях
        self.window.set_settings_paths(mods_path, save_path)
        
        # Перевіряємо чи це перший запуск
        if self.config.is_first_run() or not mods_path or not save_path:
            logger.info("Перший запуск - відкриваємо вкладку налаштувань")
            # Таймер для показу налаштувань після ініціалізації UI
            QTimer.singleShot(500, self.show_first_run_message)
        else:
            # Завантажуємо моди
            self.refresh_mods()
    
    def show_first_run_message(self):
        """Показує повідомлення першого запуску"""
        self.window.show_message(
            "Перший запуск", 
            "Будь ласка, налаштуйте шляхи до папок у вкладці Settings.", 
            "info"
        )
        # Переключаємо на вкладку Settings
        self.window.tab_widget.setCurrentIndex(2)
    
    def refresh_mods(self):
        """Оновлює список модів"""
        logger.info("Оновлення списку модів...")
        
        # Сканируем моди з деталями
        mods_detailed = self.mod_manager.scan_mods_detailed()
        active_mods = self.mod_manager.get_active_mods()
        
        # Зберігаємо метадані в конфіг
        mods_metadata = {}
        for mod in mods_detailed:
            mods_metadata[mod.id] = mod.to_dict()
        
        self.config.update_mods_metadata(mods_metadata)
        
        # Оновлюємо UI
        self.window.update_mods_list(mods_detailed, active_mods)
        
        logger.info(f"Список оновлено: {len(mods_detailed)} модів, {len(active_mods)} активних")
    
    def on_toggle_mod(self, mod_id: str):
        """Перемикає стан мода (активний/неактивний)"""
        logger.info(f"Перемикання мода: {mod_id}")
        
        # Перевіряємо поточний стан
        active_mods = self.mod_manager.get_active_mods()
        is_currently_active = mod_id in active_mods
        
        if is_currently_active:
            # Деактивуємо мод
            if self.mod_manager.deactivate_mod(mod_id):
                # Оновлюємо список активних модів
                active_mods = self.mod_manager.get_active_mods()  # Отримуємо актуальний список
                self.config.set_active_mods(active_mods)
                self.window.update_mod_status(mod_id, False)
                # Прибираємо діалог
            else:
                logger.error(f"Не вдалося деактивувати мод '{mod_id}'.")
        else:
            # Активуємо мод ОКРЕМО (не видаляючи інші)
            success, message = self.mod_manager.activate_single_mod(mod_id)
            if success:
                # Оновлюємо список активних модів
                active_mods = self.mod_manager.get_active_mods()  # Отримуємо актуальний список
                self.config.set_active_mods(active_mods)
                self.window.update_mod_status(mod_id, True)
                # Прибираємо діалог
            else:
                logger.error(f"Не вдалося активувати мод '{mod_id}': {message}")
    
    def on_apply_mods(self):
        """Застосовує вибрані моди"""
        selected_mods = self.window.get_selected_mods()
        
        if not selected_mods:
            self.window.show_message(
                "Помилка",
                "Будь ласка, виберіть хоча б один мод для активації.",
                "warning"
            )
            return
        
        # Показуємо підтвердження
        mods_list = "\n".join([f"  • {mod}" for mod in selected_mods])
        message = f"Застосувати наступні моди?\n\n{mods_list}\n\n"
        message += f"Всього: {len(selected_mods)} модів"
        
        def do_apply():
            logger.info(f"Застосування {len(selected_mods)} модів...")
            success, msg = self.mod_manager.activate_mods(selected_mods)
            
            if success:
                # Зберігаємо список активних модів в конфіг
                self.config.set_active_mods(selected_mods)
                self.window.show_message("Успіх!", msg, "info")
                # Оновлюємо список
                self.refresh_mods()
            else:
                self.window.show_message("Помилка", msg, "error")
        
        self.window.show_confirm_dialog(
            "Підтвердження",
            message,
            do_apply
        )
    
    def on_clear_mods(self):
        """Очищує всі активні моди"""
        active_mods = self.mod_manager.get_active_mods()
        
        if not active_mods:
            self.window.show_message(
                "Інформація",
                "Немає активних модів для видалення.",
                "info"
            )
            return
        
        # Простий діалог підтвердження
        logger.info("Очищення всіх модів...")
        if self.mod_manager.deactivate_all():
            self.config.set_active_mods([])
            
            # Оновлюємо статус всіх модів в UI
            for mod_id in active_mods:
                self.window.update_mod_status(mod_id, False)
            
            self.window.show_message("Успіх!", f"Деактивовано {len(active_mods)} модів.", "info")
        else:
            self.window.show_message("Помилка", "Не вдалося деактивувати моди.", "error")
    
    def on_refresh(self):
        """Оновлює список модів"""
        logger.info("Оновлення списку модів вручну...")
        self.refresh_mods()
        # Прибираємо діалог
    
    def on_open_settings(self):
        """Відкриває діалог налаштувань"""
        logger.info("Відкриття налаштувань...")
        
        current_mods = self.config.get_mods_path()
        current_save = self.config.get_save_mods_path()
        
        def on_save_settings(mods_path: str, save_path: str):
            logger.info(f"Збереження налаштувань: Mods={mods_path}, SaveMods={save_path}")
            
            # Зберігаємо в конфіг
            self.config.update({
                "mods_path": mods_path,
                "save_mods_path": save_path
            })
            
            # Оновлюємо ModManager
            self.mod_manager.set_paths(mods_path, save_path)
            
            # Позначаємо що перший запуск завершено
            if self.config.is_first_run():
                self.config.set_first_run_complete()
            
            # Оновлюємо список модів
            self.refresh_mods()
            
            self.window.show_message("Успіх!", "Налаштування збережено.", "info")
        
        # Створюємо і показуємо діалог
        SettingsDialog(
            self.window,
            current_mods,
            current_save,
            on_save_settings
        )
    
    def run(self):
        """Запускає головний цикл програми"""
        logger.info("Запуск головного циклу...")
        try:
            self.window.mainloop()
        except KeyboardInterrupt:
            logger.info("Отримано сигнал зупинки...")
        finally:
            logger.info("=== Завершення роботи Mod Manager ===")


def main():
    """Точка входу в програму"""
    try:
        app = ModManagerApp()
        app.run()
    except Exception as e:
        logger.error(f"Критична помилка: {e}", exc_info=True)
        sys.exit(1)


if __name__ == "__main__":
    main()
